apiVersion: v1
kind: ConfigMap
metadata:
  name: pingdirectory-init
data:
  init.sh: |-
    #!/bin/sh -x

    #--- Wait for services if there are any dependent services we must wait on --- #
    if test ! -z "${WAIT_FOR_SERVICES}"; then
      for SERVICE in "${WAIT_FOR_SERVICES}"; do
        until nslookup "${SERVICE}"; do
          echo "Waiting for service ${SERVICE}"
          sleep 2
        done
      done
    fi

    #--- Sleep for the configured initial delay seconds ---#
    SLEEP_SECONDS=${INITIAL_DELAY_SECONDS:-0}
    sleep ${SLEEP_SECONDS}

    #--- Copy SSH configuration files ---#
    test -f /known_hosts && cp /known_hosts /.ssh
    test -f /id_rsa && cp /id_rsa /.ssh

    # Install kubectl
    echo "Installing kubectl"
    curl https://storage.googleapis.com/kubernetes-release/release/v1.15.0/bin/linux/amd64/kubectl -o /data/kubectl
    chmod +x /data/kubectl

    #--- Generate a dummy topology JSON file so the hook that generates it in the image is not triggered ---#
    TOPOLOGY_FILE=/data/topology.json
    cat <<EOF > "${TOPOLOGY_FILE}"
    {
          "serverInstances" : []
    }
    EOF

    exit 0

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: pingdirectory-post-start
data:
  80-post-start.sh: |-
    #!/bin/sh -x

    . "${HOOKS_DIR}/pingcommon.lib.sh"

    test -f "${STAGING_DIR}/env_vars" && . "${STAGING_DIR}/env_vars"
    test -f "${HOOKS_DIR}/pingdirectory.lib.sh" && . "${HOOKS_DIR}/pingdirectory.lib.sh"

    ####################################################################################################################
    # Change the password of the provided user.
    #
    # Arguments
    #   ${1} -> The DN of the user.
    #   ${2} -> The file containing the new password file in clear text.
    #   ${3} -> Any optional control to be used with the LDAP modify request.
    #
    ####################################################################################################################
    change_user_password() {
      USER_DN="${1}"
      NEW_PASSWORD_FILE="${2}"
      CONTROL="${3}"

      echo "post-start: resetting password for user DN: ${USER_DN}"
      if test -z "${CONTROL}"; then
        ldappasswordmodify \
          --authzID "dn:${USER_DN}" \
          --newPasswordFile "${NEW_PASSWORD_FILE}"
      else
        ldappasswordmodify \
          --authzID "dn:${USER_DN}" \
          --newPasswordFile "${NEW_PASSWORD_FILE}" \
          --control "${CONTROL}"
      fi

      pwdModStatus=$?
      echo "post-start: password reset for DN ${USER_DN} status: ${pwdModStatus}"

      # The following exit codes are acceptable:
      # 0 -> success
      # 32 -> user does not exist
      # 53 -> old and new passwords are the same
      if test ${pwdModStatus} -ne 0 && test ${pwdModStatus} -ne 32 && test ${pwdModStatus} -ne 53; then
        return ${pwdModStatus}
      fi

      return 0
    }

    echo "post-start: starting post-start hook"

    # Remove this hostname from the post-start initialization marker file so the pod isn't prematurely considered ready
    POST_START_INIT_MARKER_FILE=/opt/out/instance/config/post-start-init-complete
    test -f "${POST_START_INIT_MARKER_FILE}" && sed -i.bak -E "/${HOSTNAME}/d" "${POST_START_INIT_MARKER_FILE}"

    echo "post-start: running ldapsearch test on this container (${HOSTNAME})"
    waitUntilLdapUp "localhost" "${LDAPS_PORT}" 'cn=config'

    echo "post-start: changing the cluster name to ${HOSTNAME}"
    dsconfig --no-prompt set-server-instance-prop --instance-name "${HOSTNAME}" --set cluster-name:"${HOSTNAME}"

    # FIXME:
    # DS-41417: manage-profile replace-profile has a bug today where it won't make any changes to any local-db backends
    # after setup. When manage-profile replace-profile is fixed, the following code block may be removed.

    # Create the user backend, if it does not exist or update it to the right base DN
    if ! ldapsearch --baseDN 'cn=config' --searchScope sub \
             "&(ds-cfg-backend-id=${USER_BACKEND_ID})(objectClass=ds-cfg-backend)" 1.1 &> /dev/null; then
      echo "post-start: backend ${USER_BACKEND_ID} does not exist - creating it"
      dsconfig --no-prompt create-backend \
        --type local-db \
        --backend-name "${USER_BACKEND_ID}" \
        --set "base-dn:${USER_BASE_DN}" \
        --set enabled:true \
        --set db-cache-percent:35
    else
      echo "post-start: backend ${USER_BACKEND_ID} already exists - updating base DN to ${USER_BASE_DN}"
      dsconfig --no-prompt set-backend-prop \
        --backend-name "${USER_BACKEND_ID}" \
        --set "base-dn:${USER_BASE_DN}" \
        --set enabled:true \
        --set db-cache-percent:35
    fi

    backendUpdateStatus=$?
    echo "post-start: backend ${USER_BACKEND_ID} update status: ${backendUpdateStatus}"
    test ${backendUpdateStatus} -ne 0 && exit ${backendUpdateStatus}

    # Change PF user passwords
    PASS_FILE=$(mktemp)

    echo "${PF_ADMIN_USER_PASSWORD}" > "${PASS_FILE}"
    change_user_password 'uid=administrator,ou=admins,o=platformconfig' "${PASS_FILE}"
    pwdModStatus=$?
    test ${pwdModStatus} -ne 0 && exit ${pwdModStatus}

    echo "${PF_LDAP_PASSWORD}" > "${PASS_FILE}"
    change_user_password 'uid=pingfederate,ou=devopsaccount,o=platformconfig' "${PASS_FILE}"
    pwdModStatus=$?
    test ${pwdModStatus} -ne 0 && exit ${pwdModStatus}

    # --- NOTE ---
    # This assumes that data initialization is only required once for the initial data in the server profile.
    # Subsequent initialization of data will be performed externally after populating one of the servers using data
    # sync or some other mechanism, like import-ldif, followed by dsreplication initialize-all. This assumption may be
    # different for each customer, but the script may be easily adjusted as appropriate for the customer's use case.

    SHORT_HOST_NAME=$(hostname)
    ORDINAL=$(echo ${SHORT_HOST_NAME##*-})
    echo "post-start: pod ordinal: ${ORDINAL}"

    if test ${ORDINAL} -eq 0; then
      # The request control allows encoded passwords, which is always required for topology admin users
      # ldapmodify allows a --passwordUpdateBehavior allow-pre-encoded-password=true to do the same
      ALLOW_PRE_ENCODED_PW_CONTROL='1.3.6.1.4.1.30221.2.5.51:true::MAOBAf8='
      change_user_password "cn=${ADMIN_USER_NAME}" "${ADMIN_USER_PASSWORD_FILE}" "${ALLOW_PRE_ENCODED_PW_CONTROL}"
      pwdModStatus=$?
      test ${pwdModStatus} -ne 0 && exit ${pwdModStatus}

      # Update the license file, if necessary
      LICENSE_FILE_PATH="${LICENSE_DIR}/${LICENSE_FILE_NAME}"

      if test -f "${LICENSE_FILE_PATH}"; then
        echo "post-start: updating product license from file ${LICENSE_FILE_PATH}"
        dsconfig --no-prompt set-license-prop --set "directory-platform-license-key<${LICENSE_FILE_PATH}"

        licModStatus=$?
        echo "post-start: product license update status: ${pwdModStatus}"
        test ${licModStatus} -ne 0 && exit ${licModStatus}
      fi

      echo "${HOSTNAME}" >> "${POST_START_INIT_MARKER_FILE}"
      exit 0
    fi

    # It may take the user backend a few seconds to initialize after the server is started
    USER_BASE_DN_EXISTS=false
    RETRY_COUNT=5

    for ATTEMPT in $(seq 1 "${RETRY_COUNT}"); do
      if ldapsearch --baseDN "${USER_BASE_DN}" --searchScope base '(&)' 1.1 &> /dev/null; then
        USER_BASE_DN_EXISTS=true
        echo "post-start: user base DN ${USER_BASE_DN} exists"
        break
      fi
      echo "post-start: attempt #${ATTEMPT} - user base DN ${USER_BASE_DN} does not exist"
      sleep 1s
    done

    # Bail dsreplication if user base entry is not present
    if test "${USER_BASE_DN_EXISTS}" = 'false'; then
      echo "post-start: user base DN ${USER_BASE_DN} does not exist"
      echo "${HOSTNAME}" >> "${POST_START_INIT_MARKER_FILE}"
      exit 0
    fi

    DOMAIN_NAME=$(hostname -f | cut -d'.' -f2-)
    SRC_HOST="${K8S_STATEFUL_SET_NAME}-0.${DOMAIN_NAME}"

    echo "post-start: running dsreplication enable for ${USER_BASE_DN}"
    dsreplication enable \
      --retryTimeoutSeconds ${RETRY_TIMEOUT_SECONDS} \
      --trustAll \
      --host1 "${SRC_HOST}" --port1 "${LDAPS_PORT}" --useSSL1 \
      --bindDN1 "${ROOT_USER_DN}" --bindPasswordFile1 "${ROOT_USER_PASSWORD_FILE}" \
      --host2 "${HOSTNAME}" --port2 "${LDAPS_PORT}" --useSSL2 \
      --bindDN2 "${ROOT_USER_DN}" --bindPasswordFile2 "${ROOT_USER_PASSWORD_FILE}" \
      --replicationPort2 "${REPLICATION_PORT}" \
      --adminUID "${ADMIN_USER_NAME}" --adminPasswordFile "${ADMIN_USER_PASSWORD_FILE}" \
      --no-prompt --ignoreWarnings \
      --baseDN "${USER_BASE_DN}" \
      --noSchemaReplication \
      --enableDebug --globalDebugLevel verbose

    replEnableResult=$?
    echo "post-start: replication enable for ${USER_BASE_DN} status: ${replEnableResult}"

    if test ${replEnableResult} -eq 5; then
      echo "post-start: replication is already enabled for ${USER_BASE_DN} either directly or through a parent base DN"
      echo "${HOSTNAME}" >> "${POST_START_INIT_MARKER_FILE}"
      exit 0
    fi

    if test ${replEnableResult} -ne 0; then
      echo "post-start: not running dsreplication initialize since enable failed with a non-successful return code"
      exit ${replEnableResult}
    fi

    echo "post-start: running dsreplication initialize for ${USER_BASE_DN}"
    dsreplication initialize \
      --retryTimeoutSeconds ${RETRY_TIMEOUT_SECONDS} \
      --trustAll \
      --hostSource "${SRC_HOST}" --portSource ${LDAPS_PORT} --useSSLSource \
      --hostDestination "${HOSTNAME}" --portDestination ${LDAPS_PORT} --useSSLDestination \
      --baseDN "${USER_BASE_DN}" \
      --adminUID "${ADMIN_USER_NAME}" \
      --adminPasswordFile "${ADMIN_USER_PASSWORD_FILE}" \
      --no-prompt --ignoreWarnings \
      --enableDebug \
      --globalDebugLevel verbose

    replInitResult=$?
    echo "post-start: replication initialize for ${USER_BASE_DN} status: ${replInitResult}"

    test ${replInitResult} -eq 0 && echo "${HOSTNAME}" >> "${POST_START_INIT_MARKER_FILE}"
    exit ${replInitResult}

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: pingdirectory-ready
data:
  readiness.sh: |-
    #!/bin/sh -x

    # Verify that server is responsive on its LDAP secure port
    echo "readiness: verifying root DSE access"
    /opt/liveness.sh || exit 1

    # Verify that post-start initialization is complete on this host
    echo "readiness: verifying that post-start initialization is complete on ${HOSTNAME}"
    POST_START_INIT_MARKER_FILE=/opt/out/instance/config/post-start-init-complete
    grep -q "${HOSTNAME}" "${POST_START_INIT_MARKER_FILE}" 2> /dev/null && exit 0 || exit 1

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: pingdirectory-pre-stop
data:
  pre-stop.sh: |-
    #!/bin/sh -x

    echo "pre-stop: starting pre-stop hook"

    SHORT_HOST_NAME=$(hostname)
    ORDINAL=$(echo ${SHORT_HOST_NAME##*-})
    echo "pre-stop: pod ordinal: ${ORDINAL}"

    NUM_REPLICAS=$(kubectl get statefulset "${K8S_STATEFUL_SET_NAME}" -o jsonpath='{.spec.replicas}')
    echo "pre-stop: number of replicas: ${NUM_REPLICAS}"

    if test ${ORDINAL} -lt ${NUM_REPLICAS}; then
      echo "pre-stop: not removing server since it is still in the topology"
      exit 0
    fi

    echo "pre-stop: gettting instance name from config"
    INSTANCE_NAME=$(dsconfig --no-prompt \
      --useSSL --trustAll \
      --hostname "${HOSTNAME}" --port "${LDAPS_PORT}" \
      get-global-configuration-prop \
      --property instance-name \
      --script-friendly |
      awk '{ print $2 }')

    echo "pre-stop: removing ${HOSTNAME} (instance name: ${INSTANCE_NAME}) from the topology"
    remove-defunct-server --no-prompt \
      --serverInstanceName "${INSTANCE_NAME}" \
      --retryTimeoutSeconds ${RETRY_TIMEOUT_SECONDS} \
      --ignoreOnline \
      --bindDN "${ROOT_USER_DN}" \
      --bindPasswordFile "${ROOT_USER_PASSWORD_FILE}" \
      --enableDebug --globalDebugLevel verbose
    echo "pre-stop: server removal exited with return code: ${?}"

    POST_START_INIT_MARKER_FILE=/opt/out/instance/config/post-start-init-complete
    echo "pre-stop: removing ${POST_START_INIT_MARKER_FILE} marker file"
    rm -f "${POST_START_INIT_MARKER_FILE}"

---

# Mappings for PingDirectory metrics sent to the statsd-exporter, which Prometheus will scrape
# See https://github.com/prometheus/statsd_exporter
apiVersion: v1
kind: ConfigMap
metadata:
  name: pingdirectory-statsd-mapping
data:
  pingdirectory-statsd-mapping.yml: |-
    mappings:
        # operation response time and throughput
      - match: "*.*.response-time"
        name: "response_time"
        labels:
          operation: "$2"
      - match: "*.*.throughput"
        name: "throughput"
        labels:
          operation: "$2"
        # connection handler metrics
      - match: "*.*.*.*.ldap-conn-handler-bytes-read"
        name: "LDAP_connection_handler_bytes_read"
        labels:
          port: "$4"
      - match: "*.*.*.*.ldap-conn-handler-bytes-written"
        name: "LDAP_connection_handler_bytes_written"
        labels:
          port: "$4"
      - match: "*.*.*.*.ldap-conn-handler-messages-read"
        name: "LDAP_connection_handler_messages_read"
        labels:
          port: "$4"
      - match: "*.*.*.*.ldap-conn-handler-messages-written"
        name: "LDAP_connection_handler_messages_written"
        labels:
          port: "$4"
      - match: "*.*.*.*.ldap-conn-handler-search-requests"
        name: "LDAP_connection_handler_search_requests"
        labels:
          port: "$4"
      - match: "*.*.*.*.ldap-conn-handler-search-entries-returned"
        name: "LDAP_connection_handler_search_entries_returned"
        labels:
          port: "$4"
        # backend metrics
      - match: "*.backend-entry-count"
        name: "backend_entry_count"
        labels:
          backendID: "$1"
      - match: "*.backend-db-cache-percent-full"
        name: "backend_db_cache_percent_full"
        labels:
          backendID: "$1"
      - match: "*.backend-size-on-disk"
        name: "backend_size_on_disk"
        labels:
          backendID: "$1"
      - match: "*.backend-active-cleaner-threads"
        name: "backend_active_cleaner_threads"
        labels:
          backendID: "$1"
      - match: "*.backend-cleaner-backlog"
        name: "backend_cleaner_backlog"
        labels:
          backendID: "$1"
      - match: "*.backend-nodes-evicted"
        name: "backend_nodes_evicted"
        labels:
          backendID: "$1"
      - match: "*.backend-checkpoints"
        name: "backend_checkpoints"
        labels:
          backendID: "$1"
      - match: "*.backend-avg-checkpoint-duration"
        name: "backend_avg_checkpoint_duration"
        labels:
          backendID: "$1"
      - match: "*.backend-time-since-last-checkpoint"
        name: "backend_time_since_last_checkpoint"
        labels:
          backendID: "$1"
      - match: "*.backend-new-db-logs"
        name: "backend_new_db_logs"
        labels:
          backendID: "$1"
      - match: "*.backend-random-reads"
        name: "backend_random_reads"
        labels:
          backendID: "$1"
      - match: "*.backend-random-writes"
        name: "backend_random_writes"
        labels:
          backendID: "$1"
      - match: "*.backend-sequential-reads"
        name: "backend_sequential_reads"
        labels:
          backendID: "$1"
      - match: "*.backend-sequential-writes"
        name: "backend_sequential_writes"
        labels:
          backendID: "$1"
        # entry cache metrics
      - match: "*.entry-cache-hit-ratio"
        name: "entry_cache_hit_ratio"
        labels:
          entryCache: "$1"
      - match: "*.entry-cache-hit-count"
        name: "entry_cache_hit_count"
        labels:
          entryCache: "$1"
      - match: "*.entry-cache-attempts"
        name: "entry_cache_attempts"
        labels:
          entryCache: "$1"
      - match: "*.entry-cache-add-or-update"
        name: "entry_cache_add_or_update"
        labels:
          entryCache: "$1"
      - match: "*.entry-cache-size"
        name: "entry_cache_size"
        labels:
          entryCache: "$1"
      - match: "*.entry-cache-pct-full"
        name: "entry_cache_pct_full"
        labels:
          entryCache: "$1"
        # changelog metrics?
      - match: "changelog.*"
        name: "$1"
        lables:
          backendID: "changelog"
        # GC metrics
      - match: "*.*.*.garbage-collections"
        name: "garbage_collections"
        labels:
          gcType: "$1"
          size: "$2"
          cause: "$3"
      - match: "*.*.*.garbage-collection-duration"
        name: "garbage_collection_duration"
        labels:
          gcType: "$1"
          size: "$2"
          cause: "$3"
      - match: "*.garbage-collection-live-mbytes"
        name: "garbage_collection_live_megabytes"
        labels:
          region: "$1"
