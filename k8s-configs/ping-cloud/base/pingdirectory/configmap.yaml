apiVersion: v1
kind: ConfigMap
metadata:
  name: ds-init
data:
  init.sh: |-
    #!/bin/sh -x

    #--- Sleep for the configured initial delay seconds ---#
    SLEEP_SECONDS=${INITIAL_DELAY_SECONDS:-0}
    sleep ${SLEEP_SECONDS}

    #--- Copy SSH configuration files ---#
    test -f /known_hosts && cp /known_hosts /.ssh
    test -f /id_rsa && cp /id_rsa /.ssh

    #--- Copy kubectl to the data directory ---#
    which kubectl | xargs -I {} cp {} /data

    #--- Generate the topology JSON file ---#
    NUM_REPLICAS=$(kubectl get statefulset "${K8S_STATEFUL_SET_NAME}" -o jsonpath='{.spec.replicas}')

    START=0
    END=$((${NUM_REPLICAS} - 1))

    TOPOLOGY_FILE=/data/topology.json
    DOMAIN_NAME=$(hostname -f | cut -d'.' -f2-)

    for i in $(seq 0 ${END}); do
      # Write the beginning of the "serverInstances" array
      if test ${i} -eq 0; then
        cat <<EOF >> "${TOPOLOGY_FILE}"
    {
      "serverInstances" : [
    EOF
      else
        echo ", " >> "${TOPOLOGY_FILE}"
      fi

      # Write the server instance's content
      cat <<EOF >> "${TOPOLOGY_FILE}"
        {
          "instanceName" : "${K8S_STATEFUL_SET_NAME}-${i}.${DOMAIN_NAME}",
          "hostname" : "${K8S_STATEFUL_SET_NAME}-${i}.${DOMAIN_NAME}",
          "location" : "${LOCATION}",
          "ldapPort" : ${LDAP_PORT},
          "ldapsPort" : ${LDAPS_PORT},
          "replicationPort" : ${REPLICATION_PORT},
          "startTLSEnabled" : true,
          "preferredSecurity" : "SSL",
          "product" : "DIRECTORY"
        }
    EOF

      # Write the ending of the "serverInstances" array
      if test ${i} -eq ${END}; then
      cat <<EOF >> "${TOPOLOGY_FILE}"
      ]
    }
    EOF
      fi
    done

    exit 0

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: ds-pre-stop
data:
  pre-stop.sh: |-
    #!/bin/sh -x

    LOG_FILE=/opt/out/instance/logs/tools/pre-stop.log
    echo "Starting pre-stop hook" > "${LOG_FILE}"

    SHORT_HOST_NAME=$(hostname)
    ORDINAL=$(echo ${SHORT_HOST_NAME##*-})
    echo "Pod ordinal: ${ORDINAL}" >> "${LOG_FILE}"

    NUM_REPLICAS=$(kubectl get statefulset "${K8S_STATEFUL_SET_NAME}" -o jsonpath='{.spec.replicas}')
    echo "Number of replicas: ${NUM_REPLICAS}" >> "${LOG_FILE}"

    if test ${ORDINAL} -lt ${NUM_REPLICAS}; then
      echo "Not removing server since it is still in the topology" >> "${LOG_FILE}"
      exit 0
    fi

    echo "Gettting instance name from config" >> "${LOG_FILE}"
    INSTANCE_NAME=$(dsconfig --no-prompt \
      --useSSL --trustAll \
      --hostname "${HOSTNAME}" --port "${LDAPS_PORT}" \
      get-global-configuration-prop \
      --property instance-name \
      --script-friendly |
      awk '{ print $2 }')

    echo "Removing ${HOSTNAME} (instance name: ${INSTANCE_NAME}) from the topology" >> "${LOG_FILE}"
    remove-defunct-server --no-prompt \
      --serverInstanceName "${INSTANCE_NAME}" \
      --retryTimeoutSeconds ${RETRY_TIMEOUT_SECONDS} \
      --ignoreOnline \
      --bindDN "${ROOT_USER_DN}" \
      --bindPasswordFile "${ROOT_USER_PASSWORD_FILE}" \
      --enableDebug --globalDebugLevel verbose >> "${LOG_FILE}" 2>&1
    echo "Server removal exited with return code: $?" >> "${LOG_FILE}"

    INITIALIZED_MARKER_FILE=/opt/out/instance/config/data-initialized
    echo "Removing ${INITIALIZED_MARKER_FILE} marker file" >> "${LOG_FILE}"
    rm -f "${INITIALIZED_MARKER_FILE}"

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: ds-post-start
data:
  80-post-start.sh: |-
    #!/bin/sh -x

    . "${HOOKS_DIR}/pingcommon.lib.sh"

    test -f "${STAGING_DIR}/env_vars" && . "${STAGING_DIR}/env_vars"
    test -f "${HOOKS_DIR}/pingdirectory.lib.sh" && . "${HOOKS_DIR}/pingdirectory.lib.sh"

    LOG_FILE="${SERVER_ROOT_DIR}/logs/tools/post-start.log"
    echo "Starting post-start hook" > "${LOG_FILE}"

    echo "Waiting until DNS lookup works for ${HOSTNAME}" >> "${LOG_FILE}"
    while true; do
      nslookup "${HOSTNAME}" >> "${LOG_FILE}" 2>&1 && break
      echo "Sleeping at most 5 seconds" >> "${LOG_FILE}"
      sleep_at_most 5 >> "${LOG_FILE}" 2>&1
    done

    echo "Running ldapsearch test on this container (${HOSTNAME})" >> "${LOG_FILE}"
    waitUntilLdapUp "localhost" "${LDAPS_PORT}" "" >> "${LOG_FILE}" 2>&1

    echo "Changing the cluster name to ${HOSTNAME}" >> "${LOG_FILE}"
    dsconfig --no-prompt \
      --useSSL --trustAll \
      --hostname "${HOSTNAME}" --port "${LDAPS_PORT}" \
      set-server-instance-prop \
      --instance-name "${HOSTNAME}" \
      --set cluster-name:"${HOSTNAME}" >> "${LOG_FILE}" 2>&1

    SHORT_HOST_NAME=$(hostname)
    ORDINAL=$(echo ${SHORT_HOST_NAME##*-})
    echo "Pod ordinal: ${ORDINAL}" >> "${LOG_FILE}"

    if test ${ORDINAL} -eq 0; then
      echo "Skipping dsreplication since this is the first server in the topology" >> "${LOG_FILE}"
      exit 0
    fi

    echo "Checking if ${HOSTNAME} is already in replication topology" >> $LOG_FILE
    if dsreplication --no-prompt status \
      --useSSL --trustAll \
      --port ${LDAPS_PORT} \
      --adminUID "${ADMIN_USER_NAME}" \
      --adminPasswordFile "${ADMIN_USER_PASSWORD_FILE}" | \
      grep "${HOSTNAME}"; then
      echo "${HOSTNAME} is already in replication topology" >> $LOG_FILE
      exit 0
    fi

    DOMAIN_NAME=$(hostname -f | cut -d'.' -f2-)
    HOST1="${K8S_STATEFUL_SET_NAME}-0.${DOMAIN_NAME}"

    echo "Running dsreplication enable" >> "${LOG_FILE}"
    dsreplication enable \
      --retryTimeoutSeconds ${RETRY_TIMEOUT_SECONDS} \
      --trustAll \
      --host1 "${HOST1}" --port1 "${LDAPS_PORT}" --useSSL1 \
      --bindDN1 "${ROOT_USER_DN}" --bindPasswordFile1 "${ROOT_USER_PASSWORD_FILE}" \
      --host2 "${HOSTNAME}" --port2 "${LDAPS_PORT}" --useSSL2 \
      --bindDN2 "${ROOT_USER_DN}" --bindPasswordFile2 "${ROOT_USER_PASSWORD_FILE}" \
      --replicationPort2 "${REPLICATION_PORT}" \
      --adminUID "${ADMIN_USER_NAME}" --adminPasswordFile "${ADMIN_USER_PASSWORD_FILE}" \
      --no-prompt --ignoreWarnings \
      --baseDN "${USER_BASE_DN}" \
      --noSchemaReplication \
      --enableDebug --globalDebugLevel verbose >> "${LOG_FILE}" 2>&1

    _replEnableResult=$?
    echo "Replication enable for ${HOSTNAME} result=${_replEnableResult}" >> "${LOG_FILE}"

    if test ${_replEnableResult} -ne 0; then
      echo "Not running dsreplication initialize since enable failed with a non-successful return code" >> "${LOG_FILE}"
      exit ${_replEnableResult}
    fi

    # --- NOTE ---
    # Assume that data initialization is only required once for the initial data. Subsequent initialization of data
    # will be performed externally after populating one of the servers using data sync or some other mechanism, like
    # import-ldif (using dsreplication initialize-all). This assumption may be different for each customer, but the
    # script may be easily adjusted as appropriate for the customer's use case.

    INITIALIZED_MARKER_FILE=/opt/out/instance/config/data-initialized
    if test -f "${INITIALIZED_MARKER_FILE}"; then
      echo "Skipping dsreplication initialize - data already initialized" >> "${LOG_FILE}"
      exit 0
    fi

    echo "Running dsreplication initialize" >> "${LOG_FILE}"
    dsreplication initialize \
      --retryTimeoutSeconds ${RETRY_TIMEOUT_SECONDS} \
      --trustAll \
      --hostSource "${HOST1}" --portSource ${LDAPS_PORT} --useSSLSource \
      --hostDestination "${HOSTNAME}" --portDestination ${LDAPS_PORT} --useSSLDestination \
      --baseDN "${USER_BASE_DN}" \
      --adminUID "${ADMIN_USER_NAME}" \
      --adminPasswordFile "${ADMIN_USER_PASSWORD_FILE}" \
      --no-prompt \
      --enableDebug \
      --globalDebugLevel verbose >> "${LOG_FILE}" 2>&1

    _replInitResult=$?
    echo "Replication initialize for ${HOSTNAME} result=${_replInitResult}" >> "${LOG_FILE}"

    test ${_replInitResult} -eq 0 && touch "${INITIALIZED_MARKER_FILE}"
    exit ${_replInitResult}